{"meta":{"title":"小哥","subtitle":"小哥","description":"随笔","author":"xiexiaoge","url":"xiexiaoge.github.io"},"pages":[],"posts":[{"title":"JS基础-变量提升","slug":"JS基础-变量提升","date":"2018-01-19T17:24:53.000Z","updated":"2018-01-19T17:34:03.149Z","comments":true,"path":"2018/01/20/JS基础-变量提升/","link":"","permalink":"xiexiaoge.github.io/2018/01/20/JS基础-变量提升/","excerpt":"","text":"变量提升 在当前作用域中js代码自上而下执行之前,浏览器首先会把所有带var/function关键字的进行提前声明或者定义声明(declare): var num; 在当前作用域中定义一个名字定义(defined): num=12;把声明的名字赋一个值 带 var 关键字的只是提前的声明一下; 带function关键字的在变量提升阶段把声明和定义都完成了 123456789example 1 var num =13;function fn()&#123; console.log(a)//undefined var a=10; console.log(a)//10&#125;fn();console.log(num);//13 定义变量的时候带 var 和不带var 的区别? [带var]在当前作用域中声明了一个变量,如果当前是全局作用域,也相当于给全局作用域设置了一个属性叫做a12345example 1 console.log(a) 报错 a is not defined a=12; console.log(a) //12 console.log(window.a)// 12 [不带var] 在全局作用域中,如果不带var,仅仅是给全局对象设置了一个新的属性名(把window.省略了)12345example 2 console.log(a) //undefined var a =12; console.log(a) //12 console.log(window.a)// 12 心得: 以后项目中,如果是为了创建变量,最好不要省略var,这样会更加严谨一些 作用域链 函数执行形成一个私有的作用域(可以保护私有变量),进入到私有作用域中,首先变量提升(声明过的变量是私有的),接下来代码执行 执行的时候遇到一个变量,如果这个变量是私有的,那么按照私有处理即可 123456789function fn()&#123; //=&gt;[私有作用域] //变量提升 var a;(私有变量) console.log(a);//undefined var a=12; console.log(a);//12&#125;;fn();console.log(a);// a is not defined 如果当前这个变量不是私有的,我们需要向它的上级作用域进行查找,上级如果也没有,则继续向上查找,一直找到window全局作用域为止,我们把这种查找机制叫做作用域链1) 如果上级作用域有,操作的都是上级作用域中的变量(假如我们在当前作用域把值改了,相当于把上级作用域中的这个值给修改了)2) 如果上级作用域没有这个变量(找到window也没有):变量=值:相当于给window添加一个属性 以后在操作window下就有了console.log(变量): 想要输出这个变量,如果这个变量没有的,所以会报错 1234567function fn()&#123; //console.log(a);//a is not defined a=12; console.log(a);//12&#125;;fn();console.log(a);//12 综合例子12345678910111213example 1//=&gt;变量提升 var x; var y; fn=AAAFFF111;console.log(x, y);//undefined undefinedvar x=10,y=20;function fn() &#123; //=&gt;[私有作用域] //=&gt;变量提升:var x;(x是私有变量) console.log(x, y);//x undefined ,y 20 var x=y=100; // window.y=100 console.log(x, y);//x 100 y 100&#125;fn();console.log(x,y); //10 100 注意: 这里的 var x=y=100;=&gt;var x=100 ; y=100; 只有x是一个变量,y只是window下面的一个属性, 因为从右到左赋值 只对等号左边的进行变量提升 只对等号左边进行变量提升,右边是值,不会提前声明什么的;我们创建函数的时候,可以使用函数表达式的方式: 因为只能对等号左边的进行变量提升,所以变量提升完成后,当前只是声明了,没有定义,想要执行函数,只能放在赋值的代码之后(放在前面执行相当于undefined执行,会报错) 这样让代码逻辑更加严谨,以后想要知道一个执行的函数做了什么功能,只需要向上查找定义的部分即可(不会存在定义的代码在执行下面的情况) 实名函数1234567var fn=function sum () &#123; console.log(sum);//-&gt;函数本身 console.log(1); console.log(arguments.callee);//-&gt;函数本身&#125;;//sum()=&gt;报错 sum is not definedfn(); 不管条件是否成立都要进行变量提升 不管条件是否成立,判断体中出现的var/function都会进行变量提升,但是在最新版本浏览器中,function声明的变量只能提前声明不能定义了(前提:函数是在判断题体中)123456console.log(num, fn);//undefined,undefinedif(1!==1)&#123; var num=12; function fn()&#123; &#125;&#125; 代码执行的条件判断[条件不成立]进入不到判断体中,赋值的代码执行不了,此时之前声明的变量或者函数依然是undefined [条件成立]进入条件判断体中的第一件事情不是代码执行,而是把之前变量提升没有定义的函数首先定义了(进入到判断体中函数就定义了;迎合ES6中的块级作用域)123456789console.log(num, fn);//undefined,undefinedif(1==1)&#123; console.log(num);//undefined console.log(fn);//函数体本身 var num=12; function fn()&#123; &#125;&#125; console.log(fn);//函数体本身 老版本浏览器不是这样处理的: 不管条件是否成立,都要进行变量提升(和新版本不一样的地方,新版本function只是声明,老版本function依然是声明+定义) 关于重名的处理 在变量提升阶段,如果名字重复了,不会重新的进行声明,但是会重新的进行定义(后面赋的值会把前面赋的值替换掉) 特殊变量提升的情况 = 右边不进行变量提升 自执行函数不进行变量提升 匿名函数当作参数的时候不进行变量提升 函数执行return后面的代码不执行但是需要变量提升,return出的代码执行但是不进行变量提升 if判断中的变量提升,不管条件是否成立都进行变量提升,新版本中var跟function都是只声明不定义,代码执行的时候,条件一旦成立,先给函数赋值,然后代码执行 let 和const 定义变量时,没有变量提升","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]},{"title":"JS基础-数据类型的核心操作原理","slug":"JS基础-数据类型的核心操作原理","date":"2018-01-19T03:38:09.000Z","updated":"2018-01-19T17:38:10.448Z","comments":true,"path":"2018/01/19/JS基础-数据类型的核心操作原理/","link":"","permalink":"xiexiaoge.github.io/2018/01/19/JS基础-数据类型的核心操作原理/","excerpt":"","text":"数据类型的核心操作原理 js中的数据类型 基本数据类型(值类型) number string boolean null undefined 引用数据类型 对象 {} 普通对象 [] 数组 /^$/ 正则 函数 类 JS代码运行在浏览器中,是因为浏览器给我们提供了一个供js代码执行的环境-&gt;全局作用域(window/global) 1234567891011121314151617181920212223example 1 let a= 12;// 只是给变量a 赋值 让a 和12建立链接关系 let b= a; //b-&gt;a=12 b=13; //b=13 console.log(a); ***12***个人解析:只是把a的值赋值给b ,a和b还是独立的互不影响example 2 let o=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个内存空间(aaafff111) let p=o;// -&gt; p=o-&gt;(aaafff111) p.name=\"小明\";// -&gt; aaafff111空间的name=\"小明\" console.log(o.name);// o.name-&gt;aaafff111.name-&gt;小明***小明***个人解析:因为引用数据类型,所以o,p指向地址aaafff111,p.name是堆内存中的name(后面的o,p都看成aaafff111去理解)example 3 let m=&#123;name:\"小哥\"&#125;;//-&gt;o开辟了一个堆内存(aaafff111) let n=m;//n=m-&gt;aaafff111 n=&#123;name:\"小明\"&#125;;// 这里的n 重新指向了新的地址,也就是n开辟了一个堆内存, 以后的 m和n就是独立的 console.log(m.name)个人解析:因为n重新指向了新的地址,所以以后的n和m都是独立的***小哥*** 值类型 直接按值操作,例如 let a=12;直接把12这个值赋值给变量a(让a变量和12这个值建立了链接关系) 对象数据类型 在JS中遇到对象,会严格按照如下的步骤操作: 浏览器为起开辟一个新的内存空间,为了方便后期可以找到这个空间,浏览器给空间分配一个16进行的地址(堆内存) 按照一定顺序,分别把对象键值对存储到内存空间中 把开辟内存的地址赋值给变量(或者其它的东西),以后变量就可以通过地址找到内存空间,然后进行一些操作 函数的操作 创建函数 开辟一个新的内存空间(为其分配一个16进制的地址) 把函数体中编写的js代码当作 字符串 存放到空间中(函数值创建不执行没有意义) 把分配的地址赋值给声明的函数名 执行函数 目的:执行函数体中的代码 函数执行的时候,浏览器会形成一个新的私有作用域(只能执行函数体中的代码)供函数体中的代码执行 执行代码之前,先把创建函数存储的那些字符串变为真正的js表达式,按照从上到下的顺序在私有作用域下执行 一个函数可以被执行N次,每一次执行相互之间互不干扰 形成的私有作用域把函数体中的私有变量等都包裹起来了(保护起来了),在i私有作用域下操作私有变量和外界没关系,外界也无法直接操作私有变量,我们把函数执行的这种保护机制叫做闭包闭包的机制:私有作用域保护里面的私有变量不受外界干扰","categories":[{"name":"Personal notes","slug":"Personal-notes","permalink":"xiexiaoge.github.io/categories/Personal-notes/"}],"tags":[{"name":"javascript-basis","slug":"javascript-basis","permalink":"xiexiaoge.github.io/tags/javascript-basis/"}]}]}